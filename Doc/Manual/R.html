<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>SWIG and R</title>
<link rel="stylesheet" type="text/css" href="style.css">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
</head>

<body bgcolor="#ffffff">
<H1><a name="R">37 SWIG and R</a></H1>
<!-- INDEX -->
<div class="sectiontoc">
<ul>
<li><a href="#R_nn2">Bugs</a>
<li><a href="#R_nn3">Using R and SWIG</a>
<li><a href="#R_nn4">Precompiling large R files</a>
<li><a href="#R_nn5">General policy</a>
<li><a href="#R_language_conventions">Language conventions</a>
<li><a href="#R_nn6">C++ classes</a>
<li><a href="#R_nn7">Enumerations</a>
</ul>
</div>
<!-- INDEX -->



<p>
R is a GPL'ed open source statistical and plotting environment.
Information about R can be found at <a
href="http://www.r-project.org/">www.r-project.org</a>.

The R bindings are under active development.  They have been used to
compile and run an R interface to QuantLib running on Mandriva Linux
with gcc. The R bindings also work on Microsoft Windows using Visual C++.

They have also been used to generate a binding to the SimpleITK, which
is a large and complex C++ library.

</p>

<H2><a name="R_nn2">37.1 Bugs</a></H2>


<p>
Currently the following features are not implemented or broken:
</p>

<ul>
<li>Garbage collection of create objects (Is this true?)
<li>C Array wrappings
</ul>

<H2><a name="R_nn3">37.2 Using R and SWIG</a></H2>


<p>
To use R and SWIG in C mode, execute the following commands where
example.c is the name of the file with the functions in them
</p>

<div class="shell">
<pre>
swig -r example.i
R CMD SHLIB example_wrap.c example.c
</pre>
</div>

<p>
The corresponding options for C++ mode are
</p>

<div class="shell">
<pre>
swig -c++ -r -o example_wrap.cpp example.i
R CMD SHLIB example_wrap.cpp example.cpp
</pre>
</div>

<p>
Note that R is sensitive to the names of the files.
The name of the wrapper file must be the
name of the library unless you use the -o option to R when building the library, for example:
</p>

<div class="shell">
<pre>
swig -c++ -r -o example_wrap.cpp example.i
R CMD SHLIB -o example.so example_wrap.cpp example.cpp
</pre>
</div>

<p>
R is also sensitive to the name of the file 
extension in C and C++ mode. In C++ mode, the file extension must be .cpp
rather than .cxx for the R compile command to recognize it. If your C++ code is 
in a file using something other than a .cpp extension, then it may still work using PKG_LIBS:
</p>

<div class="shell">
<pre>
swig -c++ -r -o example_wrap.cpp example.i
PKG_LIBS="example.cxx" R CMD SHLIB -o example example_wrap.cpp
</pre>
</div>

<p>
The commands produces two files.  A dynamic shared object file called
example.so, or example.dll, and an R wrapper file called example.R.  To load these
files, start up R and type in the following commands
</p>

<div class="shell">
<pre>
dyn.load(paste("example", .Platform$dynlib.ext, sep=""))
source("example.R")
cacheMetaData(1)
</pre>
</div>

The cacheMetaData(1) will cause R to refresh its object tables.
Without it, inheritance of wrapped objects may fail.

<p>
These two files can be loaded in any order
</p>

<p>
  If you are compiling code yourself (not using R itself), there are a few things to watch out for:
</p>

<ul>
<li>The output shared library name (to the left of the file extension) MUST match the module name, or alternatively, you can also set the -package NAME command line argument.  See swig -r -help for more information
<li>If you do not set the output file name appropriately, you might see errors like 
<div class="shell">
<pre>
> fact(4)
Error in .Call("R_swig_fact", s_arg1, as.logical(.copy), PACKAGE = "example") :
  "R_swig_fact" not available for .Call() for package "example"
</pre>
</div>
<li>Make sure the architecture of the shared library(x64 for instance), matches the architecture of the R program you want to load your shared library into
</ul>

<H2><a name="R_nn4">37.3 Precompiling large R files</a></H2>


In cases where the R file is large, one make save a lot of loading
time by precompiling the R wrapper.  This can be done by creating the
file makeRData.R which contains the following

<pre>
source('BigFile.R')
save(list=ls(all=TRUE),file="BigFile.RData", compress=TRUE)
q(save="no")
</pre>

This will generate a compiled R file called BigFile.RData that
will save a large amount of loading time.



<H2><a name="R_nn5">37.4 General policy</a></H2>


<p>
The general policy of the module is to treat the C/C++ as a basic
wrapping over the underlying functions and rely on the R type system
to provide R syntax.
</p>

<H2><a name="R_language_conventions">37.5 Language conventions</a></H2>


<p>
getitem and setitem use C++ conventions (i.e. zero based indices). [<-
and [ are overloaded to allow for R syntax (one based indices and
slices)
</p>

<H2><a name="R_nn6">37.6 C++ classes</a></H2>


<p>
C++ objects are implemented as external pointer objects with the class
being the mangled name of the class. The C++ classes are encapsulated
as an SEXP with an external pointer type. The class is the mangled
name of the class. The nice thing about R is that is allows you to
keep track of the pointer object which removes the necessity for a lot
of the proxy class baggage you see in other languages.

Some features to note: 

<ul>
<li> Garbage collection is via the R finalization mechanism - class
destructors get called when objects are garbage collected in R.
<li> C++ vectors and lists are automatically converted to R vectors.
</ul> 

</p>

<H2><a name="R_nn7">37.7 Enumerations</a></H2>


<p>
enumerations are characters which are then converted back and forth to
ints before calling the C routines. All of the enumeration code is
done in R. Anonymous enumerations are not wrapped. Enumerations are
represented using hidden variables and integer values are initialised
using a call to a C wrapper function.

Initialisation of enumerations has implications for code included in
an R package - calls to the functions definining the enumeration
structures need to be made after the shared library is loaded -
usually the <i>.onLoad</i> function.

For large projects this is best done using R scripts that filter out
calls to <i> defineEnumeration</i> and put them in <i>.onLoad</i>. 

<pre>
## This function uses the R language parsing capabilities.
## We're looking for calls to defineEnumeration...
## splitSwigFile("swig_generated_code.R", "zonload.R", "stuff_not_in_onload.R")
##
splitSwigFile <- function(filename, onloadfile, mainfile)
{
  p1 <- parse(file=filename)

  getdefineEnum <- function(X)
  {
    return (is.call(X) & (X[[1]]=="defineEnumeration"))
  }

  getFuncAttr <- function(X)
  {
  if (is.call(X) & X[[1]] == '=') {
        lhs <- X[[2]]
        if (length(lhs) < 2) return(FALSE)
        if ( (lhs[[1]]=='attr')) {
           return ((lhs[[3]] == 'inputTypes') | (lhs[[3]] == 'returnType'))
        }
    }
  return(FALSE)
  }
  dd <- sapply(p1, getdefineEnum)

  enums <- p1[dd]
  enums <- unlist(lapply(enums, deparse))

  ## put the function def around this
  enums <- c(".onLoad <- function(libname, pkgname) {", enums, "\n}")

  everythingelse <- p1[!dd]

  attrstuff <- sapply(everythingelse, getFuncAttr)
  everythingelse <- everythingelse[!attrstuff]

  everythingelse <- unlist(lapply(everythingelse, deparse))
  writeLines(everythingelse, mainfile)
  writeLines(enums, onloadfile)

}

</pre>

It is also useful to modify <i>enumToInteger</i>
and <i>enumFromInteger</i> so that they explicitly search the package
environment, for example, the <i>pos</i> argument below;


<pre>
enumToInteger <- function(name, type) {
    if (is.character(name)) {
        ans <- as.integer(get(paste(".__E__", type, sep = ""), pos='package:SimpleITK')[name])
        if (is.na(ans)) {
            warning("enum not found ", name, " ", type)
        }
        ans
    }
}
</pre>
</p>

</body>
</html>
